Polymorphic dynamics
====================

The library provides facilities for packing some subset of polymorphic 
values into Dynamic value with erased type information. 

This library, for example, is useful for implementing small un-typed 
scripting languages (external DSL) where it is convenient to export 
some Haskell's values. Typically this is done by means of some dictionary 
which sets name (string) to value correspondence. Haskell's base library 
has a 'Data.Dynamic.Dynamic' type which is convenient to use for encoding 
such values. But it doesn't accept polymorphic values, like 
'show :: Show a => a -> String'. So some separate value with different 
name should be exported for types we want to support in our DSL. This 
library's Dynamic type can hold values of such type. Though it has 
significantly worse performance because it has to unify type's representation 
rather than just compare them like in base library. 

Unlike standard dynamics where type's representation is given 'Typeable' 
class, the library uses explicit type's representation passed as an explicit 
argument to toDynamic and fromDynamic functions. Another option would be using 
IncoherentInstances like in [polytypeable][] but it is dangerous. It is easy 
to miss some instance and get run-time crash, probably even in production 
version on customer's side. However it is easy to add support of PolyTypeable 
into the library. The type representation can be generated by TemplateHaskell 
which should be implemented in some next version.

The type constructor of a type pattern('Ty') has 2 phantom parameters, namely 
input and output type. Generally they are different, since it is possible to 
unpack value to more specific type but it should be forbidden to pack such 
values.  For reporting such errors in compile time the library simulates rigid 
variables where type variables are replaced with predefined ground empty type 
constructors. So Haskell's type system can unify them only with other type 
variables.

It is also possible to pack constrained values, like show function. In this case 
the value should be wrapped into a type where constraints are replaced with 
"ProxyC :: Constraint -> *" parameters. And obviously the dictionary lookup 
should be performed manually in runtime. E.g. with may be a Map if the constraint 
type is ground or it may use logic programming libraries such as [logict][] along 
with [unification-fd][] for more advanced search for an instance. Some next version 
of the library may provide facilities for this. 

TODO
----

* TemplateHaskell generators for type patterns
* Facilities for dictionary search
* Factor out ground type representation for better performance
* PolyTypeable type representation option

[polytypeable]: http://hackage.haskell.org/package/polytypeable
[logict]: http://hackage.haskell.org/package/logict 
[unification-fd]: http://hackage.haskell.org/package/unification-fd


